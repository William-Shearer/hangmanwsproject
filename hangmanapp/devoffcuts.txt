# PYTHON

def fetch_word(request):
    if request.method == "GET":
        
        # If a word exists in the DB.
        if word_query := UserWordHistory.objects.filter(user = request.user, complete = False).order_by("id"):
            """
            There should never be two incomplete words for any user, but in case there is, 
            select last (only) in the history list as a safeguard.
            The order_by id is sufficient for ensuring the last() is the last or current word the
            player is working on.
            At some other stage, a routine cleaner will be implemented.
            """
            word_select = word_query.last()

            # Debug word_query
            """
            print(word_select.word)
            print(word_select.player_word)
            print(word_select.hits)
            print(word_select.misses)
            print(word_select.used_letters)
            print(word_select.complete)
            """

            """
            Right here. It is IMPORTANT to remember that the function get_word(), seen below, 
            in functions.py returns the word broken up into a list of characters. Here, the same thing
            MUST be done. The word, however, is stored in the model as a string. There is another
            very simple function in functions.py to convert an existing word in the DB into such a list
            before it is passed to the JavaScript module. Here it is in use.
            """
            # Redundant now, but good enough stuff to keep as reference for my notes.
            # word = convert_to_list(word_select.word)
            # pWord = convert_to_list(word_select.player_word)
            # print(len(word))

            """
            Change of plan. I will have JavaScript doing the conversion to and from array.
            Here, I will send the whole darn object to JavaScript and do everything up there.
            This needs to happen on two conditions.
            1. The word structure is already in the DB.
            2. The word needs creating.
            """

            # This creates a nice JavaScript acceptable object.
            data_word = {
                "userName": request.user.username,
                "word": word_select.word,
                "pWord": word_select.player_word,
                "hits": word_select.hits,
                "misses": word_select.misses,
                "usedLetters": word_select.used_letters,
                "complete": word_select.complete
            }
            # The object is returned to JavaScript at the end of this function.

        else:
            # If there was no incomplete word (or no words) in the history, create a new word.
            # This goes straight to the functions.py get_word function.
            # Remember, get_word already returns the word as a list, no need to use the convert function.
            """
            This section is for a word NOT being in the DB labelled as complete false.
            In this case, player_word needs to be constructed as a string of blanks.
            That could be done in JavaScript, too, but complicates the code. Better all
            object preparation is done here.
            """
            
            # A new word was generated because there was no incomplete word in the DB.
            # if word := get_word():
                # The blank player word needs generating.
                # Here is the Python way to do that...
                # player_word = ["_"] * len(word_select.word)
                
                # The JavaScript way to do the same thing is...
                # let str_array = Array(word.length).fill("_");
                # I put that here because this switching languages all the time is well confusing,
                # and I need some starting point to find continuity and equivalence, somehow.
                # See how that works? Hope it sinks through the ivory, now.
                
                # Important update. NOT using lists anymore. both words should be strings.
                """
                data_word = {
                    "userName": request.user.username,
                    "word": word,
                    "pWord": "_" * len(word),
                    "hits": 0,
                    "misses": 0,
                    "usedLetters": "",
                    "complete": False
                }
                """
                # If a word is created, then save the word, with all default parameters from the model.
                # Defunct, but reference for joining an array into a string...
                # UserWordHistory.objects.create(user = request.user, word = "".join(word))
                # New version...
                """
                UserWordHistory.objects.create(
                    user = request.user,
                    word = data_word["word"],
                    player_word = data_word["pWord"],
                    used_letters = ""
                )
                """
                # The object is returned to JavaScript at the end of this function.
    
            # else:
                # If there are any errors, return None. JavaScript will have to handle it frontend.
                # This is a very bad situation that should not happen, normally.
                # data_word will just send None. 
                # Not even the object, just None (which JavaScript will see as null).
                # data_word = None
                # print("ERROR: No way, no how. Word not found. Anywhere.")
                # Actually, don't even send it to JavaScript. data_word is redundant.
                # return HttpResponse("ERROR: Bad Things Are Happening.")
                # Eventually, it would be a good idea to redirect this to an error html page, 
                # where the program may recover from. Best bet there would be to perform
                # an emergency clean of the DB, and prompt the player to try again with
                # an automated fresh start.

        # Packaged off to the JavaScript module, if all went well.
    """
        return JsonResponse(data_word)
    
    else:
        return HttpResponse("ERROR: Bad! Very bad! POST request attempted here.")
    """
    # Right. That is all looking better, now.



        
    """
    if word_query := UserWordHistory.objects.filter(user = user, complete = False).order_by("id"):
        return word_query.last()
    else:
        if word := create_new_word():
            # If a word is created, then save the word, with all default parameters from the model.
            # Defunct, but reference for joining an array into a string...
            # UserWordHistory.objects.create(user = request.user, word = "".join(word))
            # New version...
            UserWordHistory.objects.create(
                user = user,
                word = word,
                player_word = "_" * len(word),
                used_letters = ""
            )
            if word_query := UserWordHistory.objects.filter(user = user, complete = False).order_by("id"):
                return word_query.last()
            else:
                return False
    """
            """
            word_query = UserWordHistory.objects.filter(user = user, complete = False).order_by("id").last()
            return word_query
            """
            """
            if repeat == True:
                get_last_user_word(user, False)
                # This case of recursion should only EVER run once, to avoid an infinite loop.
                # If it does not retrieve a record first time, something is clearly wrong.
            else:
                return False
            """
        else:
            return False

    # JAVASCRIPT

    async function fGameInitiate()
{
    /* 
    The game loop start by getting the word with fetch from Django.
    Go look at fetchword for this process. 
    This is for the timeOut signal processing.
    */
    const controller = new AbortController();
    // The timeOut function. If this fails, the game fails...
    const timeOut = setTimeout(
        function ()
        {
            controller.abort();
        },
        7000 // Seven seconds maxed out.
    );

    try
    {
        const response = await fetch("fetchword",
            {
                method: "GET",
                signal: controller.signal
            }
        );
        if (response.ok)
        {
            console.log(response.status);
            /* 
            Here the program gets the word and data back from fetchword url,
            Aka, fetch_word in views.py.
            What should come back (from Python), for reference:
            dataWord = {
                "userName": request.user.username,
                "word": word_select.word,
                "pWord": word_select.player_word,
                "hits": word_select.hits,
                "misses": word_select.misses,
                "usedLetters": word_select.used_letters,
                "complete": word_select.complete
            }
            I'm calling the receive variable much the same name as that sent from Django
            so that I don't stupidly confuse myself later... data_word, dataWord.
            */
            const dataWord = await response.json();
            // console.log(dataWord.word);
            /* 
            Test word debug.
            document.querySelector("h1").innerText = dataWord.word.join(" ");
            */
            // console.log(dataWord); // JavaScript object. Good.
            // const userName = dataWord.userName;
            // const word = dataWord.word;
            // let hits = 0;
            // let misses = 0;
            // Debug test them.
            // console.log(userName, word.join(""));
            // This is the blank word. It is not a const on purpose, as it will be altered.
            // let playerWord = Array(dataWord.word.length).fill("_");
            // Look. Don't be stupid. Just send the object to the game loop, and save all this
            // faffing about here. Jeez!
            // The game can now start...
            // fGameLoop(word, playerWord, userId, userName) //, hits, misses);
            fGameLoop(dataWord);
        }
        else
        {
            console.log(`RESPONSE ERROR: ${response.status}`)
        };
    }
    catch (error)
    {
        console.log(`NETWORK ERROR: ${error.name}`);
    }
    finally
    {
        clearTimeout(timeOut);
    };
};

/*
Take note: The application must be protected against the user reloading the browser.
That means up in the DOMContentLoaded, the word should be fetched from the Django model,
if it is incomplete. Else, a new word should be generated. This will have the effect
of saving a session, too. If the player leaves the game before finishing a word, when
they come back the same word will be presented for them to resume and complete.
*/

# Home page original in views.py
def home_page(request):
    """
    Scoring. Some special stuff here that needs an explanation:
    """
    if request.method == "GET":
        score_pairs = {
            "Expert": (501, 150000), 
            "Addicted": (251, 500), 
            "Dedicated": (51, 250), 
            "Interested": (11, 51), 
            "Sampler": (0, 10)
        }
        # Leaderboard data.
        score_records = UserScoreCard.objects.all().order_by("-won_count", "-win_ratio", "-win_efficiency")
        
        # print(score_records[0].user.username)
        qlist = list()
        level_list = list()
        inner_data = dict()
        current_user_record = None
        # current_user_data default, in case no one is logged in.
        current_user_data = {
            "level": None,
            "place": 0,
            "win_ratio": 0,
            "win_eff": 0
        }
        """
        Okay, what is this next bit doing?
        First, a loop is being established that iterates through each level found in the
        score_pairs keys.
        A score_category is created for the level, which is nothing more than all the records
        filtered by being between (inclusive) the values in the tuple for that level, taken from score records,
        which is everything in the UserScoreCards model.
        Immediately, before anymore iteration is done, it is determined if the current user is in that
        score_category range (this is for the information box on the home.html page of the site).
        If the user (logged in, of course) happens to be in that score category.
        If so, data is collected.
        Then, the first three items of the queryset for each level are collected in a temporary dict
        called qlist, which itself is made up of three other temporary dicts called inner_data.
        If there are not three places for a particular level (that is, there may not be 3 elements in
        the queryset for that level), the loop to create qlist will insert blank data instead of 
        producing an index error. 
        Finally, all of this is collected in context dict, and shunted on to the home.html page.
        It is quite a lot to put in the views.py file, so I will probably port this out to functions.py, 
        and return the data as a tuple of dicts to only be unpacked here.
        """
        # Only get the user record if someone is logged in.
        if request.user.is_authenticated:
            current_user_record = score_records.get(user = request.user)

        for level in score_pairs.keys():
            score_category = score_records.filter(won_count__gte = score_pairs[level][0], won_count__lte = score_pairs[level][1])
            
            # Only do this is someone is logged in, for obvious reasons!
            if request.user.is_authenticated:
                if current_user_record in score_category:
                    current_user_data["level"] = level
                    current_user_data["win_ratio"] = current_user_record.win_ratio
                    current_user_data["win_eff"] = current_user_record.win_efficiency
                    """
                    I have it on the word of some authorities in Django in posts on the SO and DJ  
                    that the following is the best way to find the "index" of a particular queryset.
                    Apparently, querysets are generator objects, and for some reason prefer to
                    be counted rather than being serched for by indexing. 
                    Weird, as you can also use slicing on them, which is a form of indexing.
                    Hope I clear THAT up soon. Confusing.
                    """
                    for i in range(len(score_category)):
                        if current_user_record == score_category[i]:
                            current_user_data["place"] = i + 1
                            break
            # print(current_user_data) # Anyway, it works...
            for i in range(3):
                try:
                    inner_data = {
                        "player": f"{i + 1} - {score_category[i].user.username}",
                        "won_count": f"{score_category[i].won_count}",
                        "word_count": f"{score_category[i].word_count}",
                        "win_ratio": f"{score_category[i].win_ratio}%",
                        "win_eff": f"{score_category[i].win_efficiency}%"
                    }
                    
                except IndexError:
                    inner_data = {
                        "player": f"{i + 1} - ---",
                        "won_count": "---",
                        "word_count": "---",
                        "win_ratio": "---",
                        "win_eff": "---"
                    }
                qlist.append(inner_data.copy())
                
            """
            Seen this before. Do not append the list itself, but a shallow copy of it.
            If the list itself is appended, then when cleared there will be an empty 
            list in the new qlist object.
            """
            level_list.append({level: qlist.copy()})
            qlist.clear()
            inner_data.clear()

            # What needs to be returned from the function: level_list and current_user_data.

        context = {"data": level_list, "current_user": current_user_data}
        print(context)
        return render(request, "hangmanapp/home.html", context = context)
        
    else:
        return HttpResponse("<h1>Error: Should not have a POST request.</h1>")


    